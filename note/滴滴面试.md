# **Java基础**

#### 1、在RecycleView的Adapter中，通常都会有一个ViewHolder，以下两种写法有什么区别?

```java
//第一种
pulic class viewHolder {
    ......
}
//第二种
public static class viewHolder {
    ......
}
```



#### 2、wait（） 和  sleep（）的区别？

> - wait（）是 **Object 的方法**，sleep（）是 **Thread 的静态方法** ；
>
> - wait（）**执行 的 前提** 是需要 **先持有该锁** ，否则会抛异常；若持有该锁后，执行其wait（）方法，会**释放锁的持有权**，线程进入等待状态，直到对象锁执行 **notify（） 或 notifyAll（）**之后， 线程才能 **被唤醒至运行状态，重新获取持有锁的资格**
>   **【注意：wait（time），time是等待的时间，等待的时间到了，该线程会重新去尝试获取锁，超时时间一到，便不需要等待nofify（）】**
>
>   sleep （）使线程进入阻塞状态，是**无视锁状态**的，即sleep之前，如果持有锁，**锁不会释放**；没有持有锁也不会请求锁；



#### 3、ArrayList 和 LinkedList 有什么区别？

> - ArrayList底层是一个**数组**，所以**查询快** 【为何数组查询快，请查看数据结构中 数组的特性】
> - LinkedList底层是一个**链表**，所以**增删快** 【为何链表增删快，请查看数据结构中 链表的特性】



#### 4、synchronized 修饰在 static方法和非static方法 有什么区别？

> - 当synchronized修饰一个static方法时，多线程下，获取的是类锁(即Class本身，注意:不是实例)， 作用范围是整个静态方法，作用的对象是这个类的所有对象。
>
> - 当synchronized修饰一个非static方法时，多线程下，获取的是对象锁(即类的实例对象)，作用范围是整个方法，作用对象     是调用该方法的对象
>
> - 结论: 类锁和对象锁不同，它们之间不会产生互斥

#### 5、getDeclaredMethod与getMethod 有什么区别？

> - getDeclaredMethod：获取当前类的所有声明的方法，包括public、protected和private修饰的方法。需要注意的是，这些方法一定是在当前类中声明的，从父类中继承的不算，实现接口的方法由于有声明所以包括在内。
>
> - getMethod：获取当前类和父类的所有public的方法。这里的父类，指的是继承层次中的所有父类。比如说，A继承B，B继承C，那么B和C都属于A的父类。

#### 6、线程池的实现原理，如果非核心线程执行完任务，是立即进入超时等待回收？还是从队列里取任务继续执行？

> 线程池执行任务的规则如下图：

![](E:\Desktop\MarkDown\笔记\asset\线程池任务执行规则.png)

> ​		线程池中 有个参数 **keepAliveTime** 表示非核心线程闲置的超时时间，超过这个时间则回收闲置的非核心线程。当非核心线程执行完任务后，会尝试从任务队列提取任务，若任务队列没有任务，则核心线程阻塞等待，直到取到任务执行 或 超过 **keepAliveTime** 被回收。

#### 7、DCL单例模式，两次判空的作用是什么？

> - 第一次判空，用来 **确认调用getInstance()时instance是否为空** ，如果不为空即已经创建，则直接返回，如果为空，那么就需要创建实例，于是进入synchronized同步块。
>
> - **synchronized** 加类锁，确保同时只有一个线程能进入，进入以后进行第二次判断，是因为，对于首个拿锁者，它的时段instance肯定为null，那么进入new Singleton()对象创建，而 **在首个拿锁者的创建对象期间，可能有其他线程同步调用getInstance()，那么它们也会通过第一次判空进入到同步块试图拿锁** 然后阻塞。这样的话，当首个拿锁者完成了对象创建，之后的线程都不会通过第一次判空了，而这期间阻塞的线程开始唤醒，它们则需要靠 **第二次判空来避免重复创建对象** 。

# **Android知识**

#### 1、不透明的Dialog弹出 和 透明的Dialog弹出，此时Activity的生命周期怎么变化？为什么？

> 生命周期回调都是 AMS 通过 Binder 通知应用进程调用的；而弹出 Dialog、Toast、PopupWindow 本质上都直接是通过 WindowManager.addView() 显示的（没有经过 AMS），所以**不会对生命周期有任何影响**
>
> **【面试官当时解释了，Activity的切换显示其实跟Activity的出栈和入栈有关，只有涉及到Activity的出/入栈，才会影响其生命周期，而Dialog的弹出，并没有使Activity出现出/入栈的行为】**

#### 2、LivaData怎么感知生命周期的？



#### 3、DataBinding 的实现原理



#### 4、MVP 和 MVVM 有什么区别 ？



#### 5、Handler 在 sendMessage 后，怎么切换到主线程的？切换点在什么地方？



#### 6、建造者模式有什么应用场景，为什么要用建造者模式？



#### 7、适配器模式有什么应用场景，为什么要用适配器模式？



#### 8、内存泄漏怎么产生的？怎么避免内存泄漏？